# Per implementare il sistema in python, potremmo usare la libreria NetworkX per costruire il grafo e applicare gli algoritmi di ricerca sui nodi.

# La prima cosa da fare è quindi importare la libreria NetworkX e creare un grafo vuoto:

import networkx as nx

# Crea un grafo vuoto
G = nx.Graph()

# Successivamente, possiamo leggere il file con le parole italiane e inserirle come nodi nel grafo:

# Legge il file con le parole italiane
with open("words.italian.txt") as f:
    words = f.read().splitlines()

# Inserisce le parole come nodi nel grafo
for word in words:
    G.add_node(word)

# Una volta creati i nodi, possiamo generare gli archi tra le parole in base alle regole definite. Ad esempio, per la prima regola R1, possiamo creare una funzione che prende in input due parole e restituisce True se una delle due può essere ottenuta dall'altra aggiungendo o togliendo una lettera:


def is_R1_rule(word1, word2):
    # Controlla se una parola può essere ottenuta dall'altra
    # aggiungendo o togliendo una lettera
    if len(word1) != len(word2):
        return abs(len(word1) - len(word2)) == 1
    else:
        diff = 0
        for c1, c2 in zip(word1, word2):
            if c1 != c2:
                diff += 1
        return diff == 1

# Possiamo quindi utilizzare questa funzione per generare gli archi tra le parole del grafo:


# Genera gli archi tra le parole in base alla regola R1
for word1 in G.nodes:
    for word2 in G.nodes:
        if is_R1_rule(word1, word2):
            # Assegna un peso all'arco in base alla posizione
            # della lettera aggiunta o tolta
            if len(word1) < len(word2):
                weight = word2.index(word1[-1])
            else:
                weight = word1.index(word2[-1])
            G.add_edge(word1, word2, weight=weight)

# In questo modo, avremo generato tutti gli archi tra le parole del grafo in base alla regola R1. Analogamente, potremmo generare gli archi per le altre regole R2 e R3.

# Una volta generati gli archi per la prima regola R1, possiamo generare gli archi per le altre regole R2 e R3 in modo analogo.

# Per la regola R2 (anagramma), possiamo creare una funzione che prende in input due parole e restituisce True se le due parole sono anagrammi (cioè se hanno lo stesso set di caratteri):

def is_R2_rule(word1, word2):
    # Controlla se due parole sono anagrammi
    return sorted(word1) == sorted(word2)

# Possiamo quindi utilizzare questa funzione per generare gli archi tra le parole del grafo:

# Genera gli archi tra le parole in base alla regola R2
for word1 in G.nodes:
    for word2 in G.nodes:
        if is_R2_rule(word1, word2):
            G.add_edge(word1, word2, weight=1)

# Per la regola R3 (sostituire una lettera), possiamo creare una funzione che prende in input due parole e restituisce True se una delle due può essere ottenuta dall'altra sostituendo una lettera:

def is_R3_rule(word1, word2):
    # Controlla se una parola può essere ottenuta dall'altra
    # sostituendo una lettera
    if len(word1) != len(word2):
        return False
    else:
        diff = 0
        for c1, c2 in zip(word1, word2):
            if c1 != c2:
                diff += 1
        return diff == 1

# Possiamo quindi utilizzare questa funzione per generare gli archi tra le parole del grafo:

# Genera gli archi tra le parole in base alla regola R3
for word1 in G.nodes:
    for word2 in G.nodes:
        if is_R3_rule(word1, word2):
            G.add_edge(word1, word2, weight=1)

# In questo modo, avremo generato tutti gli archi tra le parole del grafo in base alle tre regole R1, R2 e R3. A questo punto, possiamo utilizzare gli algoritmi di ricerca per trovare il cammino minimo tra due parole e calcolare la distanza tra di esse.

# Una volta costruito il grafo, possiamo utilizzare un algoritmo di ricerca come l'algoritmo di Dijkstra o A* per trovare il cammino minimo tra due nodi del grafo.

# L'algoritmo di Dijkstra è un algoritmo di ricerca che permette di trovare il cammino minimo tra due nodi in un grafo pesato. Funziona assegnando ad ogni nodo una distanza inizialmente infinita, quindi aggiornando la distanza dei nodi adiacenti al nodo di partenza a ogni iterazione. In questo modo, l'algoritmo esplora i nodi del grafo uno alla volta, cercando sempre il nodo con la distanza minima rispetto al nodo di partenza.

# Per utilizzare l'algoritmo di Dijkstra in python, possiamo usare la funzione nx.dijkstra_path() della libreria NetworkX. Questa funzione prende in input il grafo, il nodo di partenza e il nodo di destinazione, e restituisce il cammino minimo tra i due nodi:

# Trova il cammino minimo tra due parole
start_word = "parola1"
end_word = "parola2"
path = nx.dijkstra_path(G, start_word, end_word)

# L'algoritmo A* è un'altra opzione per trovare il cammino minimo tra due nodi in un grafo. A* è simile a Dijkstra, ma a differenza di quest'ultimo, tiene conto anche di una funzione di stima che permette di stimare la distanza tra il nodo corrente e il nodo di destinazione. In questo modo, l'algoritmo può esplorare in modo più efficiente i nodi del grafo, evitando di percorrere cammini non ottimali.

# Per utilizzare l'algoritmo A* in python, possiamo usare la funzione nx.astar_path() della libreria NetworkX. Questa funzione prende in input il grafo, il nodo di partenza, il nodo di destinazione e la funzione di stima, e restituisce il cammino minimo tra i due nodi:

# Definiamo una funzione di stima che calcola la distanza
# tra due parole usando la funzione di distanza di Levenshtein


def word_distance(word1, word2):
    return nltk.edit_distance(word1, word2)


# Trova il cammino minimo tra due parole usando l'algoritmo A*
start_word = "parola1"
end_word = "parola2"
path = nx.astar_path(G, start_word, end_word, word_distance)





Data la seguente funzione
def add_archs():

    for word1 in G.nodes:
        start_time = time.time()
        for word2 in G.nodes:
            # print(word1, word2, word2.find(word1[-1]))
            # Genera gli archi tra le parole in base alla regola R1
            if is_R1_rule(word1, word2):
                # Assegna un peso all'arco in base alla posizione
                # della lettera aggiunta o tolta
                if len(word1) < len(word2):
                    weight = word2.find(word1[-1])
                else:
                    weight = word1.find(word2[-1])
                G.add_edge(word1, word2, weight=weight)

            # Genera gli archi tra le parole in base alla regola R2
            if is_R2_rule(word1, word2):
                G.add_edge(word1, word2, weight=1)

            # Genera gli archi tra le parole in base alla regola R3     
            if is_R3_rule(word1, word2):
                G.add_edge(word1, word2, weight=1)
        end_time = time.time()

        print(f"Parola 1: {word1}\tTime taken: {(end_time-start_time)*10**3:.03f}ms")
Come posso aumentarne la sua efficienza in termini di tempo